import requests
import time
import os
import json
from configparser import ConfigParser
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Configuration
config = ConfigParser()
config.read('config.ini')
HA_API_KEY = config.get('HYBRID_ANALYSIS', 'API_KEY', fallback='')
HA_API_URL = 'https://www.hybrid-analysis.com/api/v2'

def analyze_with_hybrid(file_path):
    """Main analysis function that maintains compatibility with your existing code"""
    analyzer = HybridAnalyzer()
    result = analyzer.analyze_file(file_path)

    # Format the result to match what your scanner expects
    if 'error' in result:
        return result

    return {
        'score': result.get('score', 0),
        'verdict': result.get('verdict', 'unknown'),
        'signatures': result.get('signatures', []),
        'network': result.get('network', {}),
        'processes': result.get('processes', []),
        'mitre_attacks': result.get('mitre_attacks', [])
    }

class HybridAnalyzer:
    def __init__(self):
        self.severity_map = {
            1: ("Low", 1),
            2: ("Medium", 2),
            3: ("High", 3),
            4: ("Critical", 4),
            "low": ("Low", 1),
            "medium": ("Medium", 2),
            "high": ("High", 3),
            "critical": ("Critical", 4),
            "info": ("Informational", 0),
            "malicious": ("Malicious", 4),
            "suspicious": ("Suspicious", 3)
        }

    def analyze_file(self, file_path):
        """Main analysis function with complete severity and behavior handling"""
        if not HA_API_KEY:
            return {'error': 'Hybrid Analysis API key not configured'}

        try:
            # Validate file
            if not os.path.exists(file_path):
                return {'error': 'File does not exist'}
            if os.path.getsize(file_path) > 100 * 1024 * 1024:
                return {'error': 'File exceeds 100MB size limit'}

            # Setup session with retries
            session = self._create_session()

            # Get environment and submit file
            env_id = self._get_environment_id(session)
            job_id = self._submit_file(session, file_path, env_id)

            # Wait for and process report
            report = self._wait_for_report(session, job_id)
            if 'error' in report:
                return report

            return self._process_full_report(report)

        except Exception as e:
            return {'error': f'Analysis failed: {str(e)}'}

    def _create_session(self):
        """Create requests session with retry logic"""
        session = requests.Session()
        retry = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504]
        )
        session.mount('https://', HTTPAdapter(max_retries=retry))
        return session

    def _get_environment_id(self, session):
        """Get analysis environment ID"""
        try:
            response = session.get(
                f'{HA_API_URL}/system/environments',
                headers={'api-key': HA_API_KEY}
            )
            if response.status_code == 200:
                for env in response.json():
                    if env['architecture'] == 'WINDOWS' and env['os_version'] == 'Windows 10':
                        return env['id']
        except:
            pass
        return 120  # Default Windows 10 64-bit

    def _submit_file(self, session, file_path, env_id):
        """Submit file for analysis"""
        with open(file_path, 'rb') as f:
            response = session.post(
                f'{HA_API_URL}/submit/file',
                files={
                    'file': (os.path.basename(file_path), f),
                    'environment_id': (None, str(env_id))
                },
                headers={
                    'api-key': HA_API_KEY,
                    'user-agent': 'MalwareAnalyzer/2.0'
                }
            )

        if response.status_code != 201:
            error_msg = response.json().get('message', 'Unknown error')
            raise Exception(f'Submission failed: {error_msg}')

        return response.json().get('job_id')

    def _wait_for_report(self, session, job_id, timeout=600, interval=15):
        """Wait for analysis completion"""
        start_time = time.time()

        while time.time() - start_time < timeout:
            status = session.get(
                f'{HA_API_URL}/report/{job_id}/state',
                headers={'api-key': HA_API_KEY}
            ).json()

            state = status.get('state')
            if state == 'SUCCESS':
                report = session.get(
                    f'{HA_API_URL}/report/{job_id}/summary',
                    headers={'api-key': HA_API_KEY}
                )
                if report.status_code == 200:
                    return report.json()
                raise Exception(f'Failed to get report: {report.text}')
            elif state in ['FAILED', 'ERROR']:
                raise Exception(f'Analysis failed: {state}')

            time.sleep(interval)

        raise Exception('Analysis timed out')

    def _process_full_report(self, report):
        """Process complete report with enhanced details"""
        # Save raw report for debugging
        with open('hybrid_analysis_raw.json', 'w') as f:
            json.dump(report, f, indent=2)

        return {
            'verdict': self._get_verdict(report),
            'score': report.get('threat_score', 0),
            'signatures': self._process_signatures(report),
            'network': self._process_network(report),
            'processes': self._process_processes(report),
            'mitre_attacks': self._process_mitre_attacks(report),
            'dropped_files': self._process_dropped_files(report),
            'indicators': self._process_indicators(report),
            'timeline': self._process_timeline(report)
        }

    def _get_verdict(self, report):
        """Get formatted verdict"""
        verdict = report.get('verdict', 'no_verdict')
        if isinstance(verdict, str):
            return verdict.capitalize()
        return str(verdict)

    def _process_signatures(self, report):
        """Process all detection signatures with proper severity"""
        signatures = []

        for sig in report.get('signatures', []):
            # Get severity from multiple possible fields
            severity_val = (
                    sig.get('severity_level') or
                    sig.get('severity') or
                    sig.get('risk_level') or
                    sig.get('relevance', 1)
            )

            # Normalize severity
            if isinstance(severity_val, str):
                severity_val = severity_val.lower()

            severity = self.severity_map.get(severity_val)
            if not severity:
                try:
                    severity_val = int(severity_val)
                    severity = self.severity_map.get(severity_val, ("Unknown", 0))
                except (ValueError, TypeError):
                    severity = ("Unknown", 0)

            signatures.append({
                'name': sig.get('name', 'Unknown'),
                'description': sig.get('description', ''),
                'severity': severity[0],
                'severity_value': severity[1],
                'category': sig.get('category', ''),
                'technique': sig.get('attack_technique'),
                'tactic': sig.get('attack_tactic'),
                'raw_data': sig
            })

        return sorted(signatures, key=lambda x: -x['severity_value'])

    def _process_network(self, report):
        """Process network activity with threat scoring"""
        network = report.get('network', {})
        return {
            'domains': [{
                'domain': d.get('domain'),
                'ip': d.get('ip'),
                'country': d.get('country'),
                'risk': d.get('risk', 'unknown')
            } for d in network.get('domains', [])],
            'hosts': [{
                'ip': h.get('ip'),
                'ports': h.get('ports', []),
                'country': h.get('country'),
                'asn': h.get('asn')
            } for h in network.get('hosts', [])],
            'dns': [{
                'request': d.get('request'),
                'type': d.get('type'),
                'answers': [a.get('answer') for a in d.get('answers', [])]
            } for d in network.get('dns', [])],
            'http': [{
                'method': h.get('method'),
                'url': h.get('url'),
                'status': h.get('status'),
                'user_agent': h.get('user_agent')
            } for h in network.get('http', [])]
        }

    def _process_processes(self, report):
        """Process process behavior with critical actions"""
        return [{
            'name': p.get('process_name'),
            'pid': p.get('pid'),
            'parent_pid': p.get('parent_pid'),
            'actions': [{
                'type': a.get('type'),
                'target': a.get('target'),
                'critical': a.get('critical', False)
            } for a in p.get('actions', []) if a.get('type')],
            'calls': [c.get('api') for c in p.get('calls', [])
                      if c.get('suspicious', False)]
        } for p in report.get('processes', [])]

    def _process_mitre_attacks(self, report):
        """Process MITRE ATT&CK techniques with severity"""
        return [{
            'technique': a.get('technique'),
            'id': a.get('technique_id'),
            'tactic': a.get('tactic'),
            'severity': a.get('severity', 'medium').capitalize(),
            'description': a.get('description')
        } for a in report.get('mitre_attacks', [])]

    def _process_dropped_files(self, report):
        """Process files dropped during execution"""
        return [{
            'name': f.get('name'),
            'path': f.get('path'),
            'type': f.get('type'),
            'hashes': {
                'md5': f.get('md5'),
                'sha1': f.get('sha1'),
                'sha256': f.get('sha256')
            },
            'threat_level': f.get('threat_level', 'unknown')
        } for f in report.get('dropped_files', [])]

    def _process_indicators(self, report):
        """Process threat indicators"""
        return {
            'network': report.get('network_indicators', []),
            'file': report.get('file_indicators', []),
            'process': report.get('process_indicators', []),
            'yara': report.get('yara', [])
        }

    def _process_timeline(self, report):
        """Process behavioral timeline"""
        return [{
            'time': e.get('time'),
            'process': e.get('process_name'),
            'action': e.get('action'),
            'target': e.get('target')
        } for e in report.get('behavior', {}).get('events', [])]