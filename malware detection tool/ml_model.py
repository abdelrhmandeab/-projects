import pickle
import os
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, classification_report
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MLModel:
    def __init__(self):
        self.model = None
        self.scaler = None  # Initialize as None to check if fitted
        self.model_path = 'malware_model.pkl'
        self.scaler_path = 'scaler.pkl'
        self.load_model()

    def load_model(self):
        """Load the trained model and scaler or initialize a new one"""
        try:
            if os.path.exists(self.model_path) and os.path.exists(self.scaler_path):
                with open(self.model_path, 'rb') as f:
                    self.model = pickle.load(f)
                with open(self.scaler_path, 'rb') as f:
                    self.scaler = pickle.load(f)
                logger.info("Loaded pre-trained model and scaler")
            else:
                logger.warning("No pre-trained model or scaler found. Model requires training before use.")
                self.model = RandomForestClassifier(
                    n_estimators=100,
                    max_depth=20,
                    min_samples_split=5,
                    min_samples_leaf=2,
                    random_state=42,
                    n_jobs=-1
                )
                self.scaler = None  # Scaler will be fitted during training
        except Exception as e:
            logger.error(f"Error loading model: {e}")
            self.model = None
            self.scaler = None

    def save_model(self):
        """Save the current model and scaler to disk"""
        try:
            with open(self.model_path, 'wb') as f:
                pickle.dump(self.model, f)
            if self.scaler is not None:
                with open(self.scaler_path, 'wb') as f:
                    pickle.dump(self.scaler, f)
            logger.info("Model and scaler saved successfully")
        except Exception as e:
            logger.error(f"Error saving model: {e}")

    def train_model(self, X, y):
        """Train the model with provided features and labels"""
        try:
            if self.model is None:
                raise ValueError("Model not initialized")

            # Initialize and fit scaler
            self.scaler = StandardScaler()
            X_scaled = self.scaler.fit_transform(X)
            
            # Train the model
            self.model.fit(X_scaled, y)
            
            # Evaluate with cross-validation
            cv_scores = cross_val_score(self.model, X_scaled, y, cv=5, scoring='accuracy')
            logger.info(f"Cross-validation accuracy: {np.mean(cv_scores):.4f} Â± {np.std(cv_scores):.4f}")
            
            # Save the trained model and scaler
            self.save_model()
            
            return np.mean(cv_scores)
        except Exception as e:
            logger.error(f"Error training model: {e}")
            return 0

    def predict(self, features):
        """Make a prediction using the model"""
        if self.model is None or self.scaler is None:
            logger.error("Model or scaler not available. Please train the model first.")
            return {'error': 'Model or scaler not available. Please train the model first.', 'prediction': 'unknown', 'confidence': 0}

        try:
            # Ensure features are in the correct shape
            features = np.array(features).reshape(1, -1)
            
            # Scale features
            features_scaled = self.scaler.transform(features)
            
            # Predict
            pred = self.model.predict(features_scaled)[0]
            proba = self.model.predict_proba(features_scaled)[0][1]  # Probability of being malicious
            
            return {
                'prediction': 'malicious' if pred == 1 else 'benign',
                'confidence': float(proba)
            }
        except Exception as e:
            logger.error(f"Error during prediction: {e}")
            return {'error': str(e), 'prediction': 'unknown', 'confidence': 0}

# Global model instance
ml_model = MLModel()