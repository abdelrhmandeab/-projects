import pefile
import hashlib
import magic
import os
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def analyze_with_peframe(file_path):
    """
    Analyze a PE file using static analysis with pefile.

    Args:
        file_path (str): Path to the file to analyze

    Returns:
        dict: Analysis results including file info, PE info, and malware indicators,
              or error information if analysis fails
    """
    logger.info(f"Starting PEframe analysis for file: {file_path}")
    try:
        if not os.path.isfile(file_path):
            logger.error(f"File does not exist: {file_path}")
            return {'error': f'File does not exist: {file_path}'}

        result = {
            'file_info': get_file_info(file_path),
            'pe_info': get_pe_info(file_path),
            'indicators': check_malware_indicators(file_path)
        }
        logger.info(f"PEframe analysis completed for file: {file_path}")
        return result
    except Exception as e:
        logger.error(f"PEframe analysis failed for {file_path}: {str(e)}")
        return {'error': f'PEframe analysis failed: {str(e)}'}


def get_file_info(file_path):
    """
    Extract basic file information (size, type, hashes).

    Args:
        file_path (str): Path to the file

    Returns:
        dict: File metadata including filename, size, type, and hashes
    """
    try:
        file_info = {
            'filename': os.path.basename(file_path),
            'file_size': os.path.getsize(file_path),
            'file_type': magic.from_file(file_path),
            'md5': get_file_hash(file_path, 'md5'),
            'sha1': get_file_hash(file_path, 'sha1'),
            'sha256': get_file_hash(file_path, 'sha256')
        }
        return file_info
    except Exception as e:
        logger.error(f"Failed to get file info for {file_path}: {str(e)}")
        return {'error': str(e)}


def get_file_hash(file_path, algorithm='sha256'):
    """
    Calculate the hash of a file.

    Args:
        file_path (str): Path to the file
        algorithm (str): Hash algorithm ('md5', 'sha1', 'sha256')

    Returns:
        str: Hexadecimal hash value
    """
    try:
        hash_func = getattr(hashlib, algorithm)()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b''):
                hash_func.update(chunk)
        return hash_func.hexdigest()
    except Exception as e:
        logger.error(f"Failed to compute {algorithm} hash for {file_path}: {str(e)}")
        return f'Error: {str(e)}'


def get_pe_info(file_path):
    """
    Extract PE file structure information.

    Args:
        file_path (str): Path to the PE file

    Returns:
        dict: PE structure details (entry point, sections, imports, exports, etc.)
    """
    try:
        pe = pefile.PE(file_path)
        pe_info = {
            'entry_point': pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            'sections': [],
            'imports': [],
            'exports': [],
            'compile_time': pe.FILE_HEADER.TimeDateStamp
        }

        for section in pe.sections:
            pe_info['sections'].append({
                'name': section.Name.decode().rstrip('\x00'),
                'virtual_size': section.Misc_VirtualSize,
                'raw_size': section.SizeOfRawData,
                'entropy': section.get_entropy()
            })

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                imports = []
                for imp in entry.imports:
                    if imp.name:
                        imports.append(imp.name.decode())
                pe_info['imports'].append({
                    'dll': entry.dll.decode(),
                    'functions': imports
                })

        return pe_info
    except pefile.PEFormatError as e:
        logger.error(f"Invalid PE file format for {file_path}: {str(e)}")
        return {'error': f'Invalid PE file: {str(e)}'}
    except Exception as e:
        logger.error(f"Failed to get PE info for {file_path}: {str(e)}")
        return {'error': str(e)}


def check_malware_indicators(file_path):
    """
    Check for malware indicators in the PE file.

    Args:
        file_path (str): Path to the PE file

    Returns:
        dict: Indicators of potential malicious behavior
    """
    indicators = {
        'packed': False,
        'anti_debug': False,
        'suspicious_imports': False,
        'suspicious_sections': False
    }

    try:
        pe = pefile.PE(file_path)

        # Check for packing
        sections = [s.Name.decode().rstrip('\x00').lower() for s in pe.sections]
        if any(name in sections for name in ['upx', 'packed', '.aspack']):
            indicators['packed'] = True

        # Check for anti-debug techniques
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll = entry.dll.decode().lower()
                if dll == 'kernel32.dll':
                    for imp in entry.imports:
                        if imp.name:
                            func = imp.name.decode().lower()
                            if func in ['isdebuggerpresent', 'checkremotedebuggerpresent']:
                                indicators['anti_debug'] = True

        # Check for suspicious imports
        suspicious_imports = ['virtualalloc', 'createthread', 'writeprocessmemory']
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    if imp.name and imp.name.decode().lower() in suspicious_imports:
                        indicators['suspicious_imports'] = True

        # Check section characteristics
        for section in pe.sections:
            if section.SizeOfRawData == 0 and section.Misc_VirtualSize > 0:
                indicators['suspicious_sections'] = True
            if section.get_entropy() > 7.0:  # High entropy suggests packing/encryption
                indicators['packed'] = True

        return indicators
    except pefile.PEFormatError as e:
        logger.error(f"Invalid PE file format for {file_path}: {str(e)}")
        return {'error': f'Invalid PE file: {str(e)}'}
    except Exception as e:
        logger.error(f"Failed to check malware indicators for {file_path}: {str(e)}")
        return {'error': str(e)}