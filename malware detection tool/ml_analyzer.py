from ml_model import ml_model
from pefile import PE
import os
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def analyze_with_ml(file_path):
    """Analyze a file using the ML model"""
    try:
        features = extract_features(file_path)
        if 'error' in features:
            return features
        return ml_model.predict(features)
    except Exception as e:
        logger.error(f"Error in ML analysis: {e}")
        return {'error': str(e)}

def extract_features(file_path):
    """Extract features from PE file for ML analysis"""
    try:
        pe = PE(file_path)
        
        # Basic header information
        size_of_code = pe.OPTIONAL_HEADER.SizeOfCode
        size_of_initialized_data = pe.OPTIONAL_HEADER.SizeOfInitializedData
        size_of_uninitialized_data = pe.OPTIONAL_HEADER.SizeOfUninitializedData
        image_base = pe.OPTIONAL_HEADER.ImageBase
        major_linker_version = pe.OPTIONAL_HEADER.MajorLinkerVersion
        minor_linker_version = pe.OPTIONAL_HEADER.MinorLinkerVersion

        # Section information
        section_count = len(pe.sections)
        entropy = []
        virtual_size = []
        raw_size = []
        suspicious_section_name = 0
        executable_sections = 0
        writable_sections = 0

        for section in pe.sections:
            entropy.append(section.get_entropy())
            virtual_size.append(section.Misc_VirtualSize)
            raw_size.append(section.SizeOfRawData)
            name = section.Name.decode().rstrip('\x00').lower()
            if any(x in name for x in ['pack', 'upx', 'vmp', 'themida']):
                suspicious_section_name = 1
            if section.Characteristics & 0x20000000:  # IMAGE_SCN_CNT_CODE
                executable_sections += 1
            if section.Characteristics & 0x80000000:  # IMAGE_SCN_MEM_WRITE
                writable_sections += 1

        avg_entropy = sum(entropy) / len(entropy) if entropy else 0
        max_entropy = max(entropy) if entropy else 0
        avg_virtual_size = sum(virtual_size) / len(virtual_size) if virtual_size else 0
        avg_raw_size = sum(raw_size) / len(raw_size) if raw_size else 0

        # Import/export information
        import_count = 0
        suspicious_import = 0
        dll_count = 0
        export_count = 0

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            import_count = len(pe.DIRECTORY_ENTRY_IMPORT)
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode().lower()
                dll_count += 1
                if 'kernel32' in dll_name or 'user32' in dll_name:
                    suspicious_import = 1
                for imp in entry.imports:
                    if imp.name:
                        func = imp.name.decode().lower()
                        if func in ['virtualalloc', 'createthread', 'writeprocessmemory']:
                            suspicious_import = 1

        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            export_count = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)

        # Resource information
        resource_count = 0
        resource_size = 0
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            try:
                for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    for resource in resource_type.directory.entries:
                        if hasattr(resource.data, 'struct') and hasattr(resource.data.struct, 'Size'):
                            resource_count += 1
                            resource_size += resource.data.struct.Size
            except AttributeError:
                logger.warning(f"Resource directory parsing failed for {file_path}. Using default values.")
                resource_count = 0
                resource_size = 0

        # Other characteristics
        has_debug = 1 if hasattr(pe, 'DIRECTORY_ENTRY_DEBUG') else 0
        has_relocations = 1 if hasattr(pe, 'DIRECTORY_ENTRY_BASERELOC') else 0
        has_resources = 1 if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE') else 0
        has_signature = 1 if hasattr(pe, 'DIRECTORY_ENTRY_SECURITY') else 0
        
        # Header anomalies
        suspicious_image_base = 1 if image_base < 0x10000 else 0
        import_export_ratio = import_count / (export_count + 1)  # Avoid division by zero

        return [
            size_of_code, size_of_initialized_data, size_of_uninitialized_data,
            avg_entropy, max_entropy, avg_virtual_size, avg_raw_size,
            dll_count, suspicious_import, suspicious_section_name,
            section_count, import_count, export_count, import_export_ratio,
            has_debug, has_relocations, has_resources, has_signature,
            resource_count, resource_size, executable_sections, writable_sections,
            suspicious_image_base, major_linker_version, minor_linker_version
        ]
    except Exception as e:
        logger.error(f"Error extracting features: {e}")
        return {'error': str(e)}